# Secrets Variables
## ARGOCD_AUTH_TOKEN
## ARGOCD_SERVER
## DEFECTDOJO_HOST
## DEFECTDOJO_TOKEN
## DOCKERHUB_TOKEN
## DOCKERHUB_USERNAME
## SONARQUBE_TOKEN
## SONARQUBE_HOST
## SONARQUBE_ORG

name: CI/CD for Opsta Line BOT

env:
  IMAGE_NAME: ghcr.io/opsta/opsta-linebot

on:
  push:
    paths-ignore:
      - 'README.md'
      - 'Makefile'
      - 'docker-compose.yml'
      - '.gitignore'
      - 'requirements-orig-*.txt'
      - '.devcontainer/**'
      - 'iac/**'
    tags:
      - "v[0-9]+.[0-9]+.[0-9]+"
    branches:
      - "main"

jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set DEPLOY_ENV for production
        if: startsWith(github.ref, 'refs/tags/v')
        run: echo "DEPLOY_ENV=prd" >> "$GITHUB_ENV"
      - name: Set DEPLOY_ENV for non-production
        if: startsWith(github.ref, 'refs/tags/v') != true
        run: |
          if [[ ${{ github.ref_name }} == 'main' || ${{ github.ref_name }} == 'master' ]]; then
            echo "DEPLOY_ENV=dev" >> "$GITHUB_ENV"
          else
            echo "DEPLOY_ENV=${{ github.ref_name }}" >> "$GITHUB_ENV"
          fi
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          # list of Docker images to use as base name for tags
          images: ${{ env.IMAGE_NAME }}
          # generate Docker tags based on the following events/attributes
          tags: |
            # branch event
            type=ref,event=branch
            # tag edge on default branch
            type=edge
            # dynamically set the branch name as a prefix
            type=sha,prefix=${{ env.DEPLOY_ENV }}-,priority=750
            # push tag event on valid semver git tag
            type=semver,pattern={{raw}}
    # For use in other jobs
    outputs:
      tags: "${{ steps.meta.outputs.tags }}"
      labels: "${{ steps.meta.outputs.labels }}"
      version: "${{ steps.meta.outputs.version }}"
      deploy_env: "${{ env.DEPLOY_ENV }}"

  # defectdojo-engagement:
  #   runs-on: ubuntu-latest
  #   if: startsWith(github.ref, 'refs/tags/v') != true
  #   needs:
  #     - setup
  #   steps:
  #     - name: Create DefectDojo Product if not exists with Engagement
  #       run: |
  #         # Timestamp variables
  #         TODAY=$(date +%Y-%m-%d)
  #         ENDDAY=$(date -d "+1 days" +%Y-%m-%d)
  #         echo "TODAY: ${TODAY}"
  #         echo "ENDDAY: ${ENDDAY}"

  #         # Get DefectDojo Product ID
  #         DEFECTDOJO_PRODUCT_ID=$(curl -X GET "${{ secrets.DEFECTDOJO_HOST }}/api/v2/products/?name_exact=${{ github.event.repository.name }}" \
  #           --header "Authorization:Token ${{ secrets.DEFECTDOJO_TOKEN }}" \
  #           --header "Accept:application/json" --fail-with-body | jq -r '.results[0].id // empty')
  #         echo "DEFECTDOJO_PRODUCT_ID: ${DEFECTDOJO_PRODUCT_ID}"

  #         # Create DefectDojo Product if not exists
  #         if [[ -z "${DEFECTDOJO_PRODUCT_ID}" ]]; then
  #           # Set DefectDojo Payload for Product
  #           PAYLOAD=$(cat << JSON
  #           {
  #             "tags": ["github-actions"],
  #             "name": "${{ github.event.repository.name }}",
  #             "description": "${{ github.event.repository.name }}",
  #             "prod_type": 1,
  #             "sla_configuration": 1
  #           }
  #           JSON
  #           )
  #           echo "PAYLOAD_PRODUCT: ${PAYLOAD}"

  #           # Create DefectDojo Product and get Product ID
  #           DEFECTDOJO_PRODUCT_ID=$(curl -X POST "${{ secrets.DEFECTDOJO_HOST }}/api/v2/products/" \
  #             --header "Authorization:Token ${{ secrets.DEFECTDOJO_TOKEN }}" \
  #             --header "Content-Type:application/json" \
  #             --data-raw "${PAYLOAD}" --fail-with-body | jq -r '.id')
  #           echo "DEFECTDOJO_PRODUCT_ID: ${DEFECTDOJO_PRODUCT_ID}"
  #         fi

  #         # Set DefectDojo Payload for Engagement
  #         PAYLOAD=$(cat << JSON
  #         {
  #           "tags": ["github-actions"],
  #           "name": "${{ needs.setup.outputs.deploy_env }}-${{ github.run_id }}",
  #           "first_contacted": "${TODAY}",
  #           "target_start": "${TODAY}",
  #           "target_end": "${ENDDAY}",
  #           "version": "${{ needs.setup.outputs.version }}",
  #           "engagement_type": "CI/CD",
  #           "build_id": "${{ github.run_id }}",
  #           "commit_hash": "${{ github.sha }}",
  #           "branch_tag": "${{ github.ref_name }}",
  #           "product": "${DEFECTDOJO_PRODUCT_ID}",
  #           "source_code_management_uri": "${{ github.repositoryUrl }}"
  #         }
  #         JSON
  #         )
  #         echo "PAYLOAD_ENGAGEMENT: ${PAYLOAD}"

  #         # Create DefectDojo Engagement
  #         curl -X POST "${{ secrets.DEFECTDOJO_HOST }}/api/v2/engagements/" \
  #           --header "Authorization:Token ${{ secrets.DEFECTDOJO_TOKEN }}" \
  #           --header "Content-Type:application/json" \
  #           --data-raw "${PAYLOAD}" --fail-with-body | jq -e -r '.id'

  sonarqube:
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v') != true
    needs:
      - setup
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Disabling shallow clones is recommended for improving the relevancy of reporting
          fetch-depth: 0
      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@v3
        with:
          args: >
            -D sonar.organization=${{ secrets.SONARQUBE_ORG }}
            -D sonar.projectKey=${{ github.event.repository.name }}
            -D sonar.sources=.
            -D sonar.qualitygate.wait=true
        env:
          SONAR_TOKEN: ${{ secrets.SONARQUBE_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONARQUBE_HOST }}
      - name: Create SonarQube Report for DefectDojo
        if: always()
        run: |
          # Install Sonar Report
          mkdir -p ~/.local/bin
          npm config set prefix '~/.local/'
          npm install --global sonar-report@3.1.6

          # Always run SAST Report from SonarQube
          export PATH=~/.local/bin/:$PATH
          # On SonarQube Community edition, you only can use main branch
          sonar-report \
            --sonarorganization="${{ secrets.SONARQUBE_ORG }}" \
            --sonarurl="${{ secrets.SONARQUBE_HOST }}" \
            --sonartoken="${{ secrets.SONARQUBE_TOKEN }}" \
            --sonarcomponent="${{ github.event.repository.name }}" \
            --project="${{ github.event.repository.name }}" \
            --application="${{ github.event.repository.name }}" \
            --release="${{ needs.setup.outputs.version }}" \
            --output="sonar-report.html" \
            --branch="main"
      - name: Upload Sonar Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sonar-report
          path: sonar-report.html
          retention-days: 1

  # For non-production environments
  build-push:
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v') != true
    needs:
      - setup
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Login to Docker Hub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # - name: Set up QEMU (optional)
      #   uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ needs.setup.outputs.tags }}
          labels: ${{ needs.setup.outputs.labels }}
          cache-to: type=registry,ref=${{ env.IMAGE_NAME }}:buildcache,mode=max
          cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:buildcache
        env:
          DOCKER_BUILD_RECORD_UPLOAD: false

  # For production environment
  tag-prd:
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    needs:
      - setup
    steps:
      - name: Login to Docker Hub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Setup Crane
        uses: imjasonh/setup-crane@v0.4
      - name: Copy Docker Image from dev to production
        run: crane copy ${{ env.IMAGE_NAME }}:edge ${{ env.IMAGE_NAME }}:${{ needs.setup.outputs.version }}

  # Commit to Git for ArgoCD
  gitops-commit:
    runs-on: ubuntu-latest
    # run after all of needs are complete (whether skipped or success)
    if: ${{ !cancelled() && !failure() }}
    needs:
      - setup
      - build-push
      - tag-prd
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Update Image Version in Helm Value file
        uses: fjogeleit/yaml-update-action@main
        with:
          valueFile: "iac/helm-values/opsta-line-bot-${{ needs.setup.outputs.deploy_env }}.yaml"
          propertyPath: image.tag
          value: ${{ needs.setup.outputs.version }}
          branch: main
          message: "Update Image Version to ${{ needs.setup.outputs.version }}"

  # ArgoCD Sync
  gitops-sync:
    runs-on: ubuntu-latest
    container:
      image: quay.io/argoproj/argocd:v2.12.4
      env:
        ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
        ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
    # run after all of needs are complete (whether skipped or success)
    if: ${{ !cancelled() && !failure() }}
    needs:
      - setup
      - gitops-commit
    steps:
      - name: Sync ArgoCD
        run: |
          argocd app sync demo-opsta-line-bot-${{ needs.setup.outputs.deploy_env }}/opsta-line-bot-${{ needs.setup.outputs.deploy_env }} --project demo
          argocd app wait demo-opsta-line-bot-${{ needs.setup.outputs.deploy_env }}/opsta-line-bot-${{ needs.setup.outputs.deploy_env }} --health

  defectdojo-import:
    runs-on: ubuntu-latest
    if: always() && startsWith(github.ref, 'refs/tags/v') != true
    needs:
      - setup
      # - defectdojo-engagement
      - sonarqube
    steps:
      - name: Download all workflow run artifacts
        uses: actions/download-artifact@v4
        with:
          merge-multiple: true
      - name: Import Security Test Report to DefectDojo
        run: |
          # Timestamp variables
          TODAY=$(date +%Y-%m-%d)

          # Import DefectDojo from Report
          curl -X POST "${{ secrets.DEFECTDOJO_HOST }}/api/v2/import-scan/" --fail-with-body \
            --header "Content-Type:multipart/form-data" \
            --header "Authorization:Token ${{ secrets.DEFECTDOJO_TOKEN }}" \
            --form scan_date="${TODAY}" \
            --form product_name="${{ github.event.repository.name }}" \
            --form product_type_name="Research and Development" \
            --form engagement_name="${{ needs.setup.outputs.deploy_env }}-${{ github.run_id }}" \
            --form environment="${{ needs.setup.outputs.deploy_env }}" \
            --form close_old_findings="true" \
            --form close_old_findings_product_scope="true" \
            --form minimum_severity="Info" \
            --form service="${{ github.event.repository.name }}" \
            --form file=@"${{ matrix.defectdojo_report_file }}" \
            --form scan_type="${{ matrix.defectdojo_scan_type }}" \
            --form test_title="${{ matrix.defectdojo_test_title }}" \
            --form deduplication_on_engagement="true" \
            --form auto_create_context="true"
    strategy:
      matrix:
        include:
          - defectdojo_report_file: sonar-report.html
            defectdojo_scan_type: SonarQube Scan
            defectdojo_test_title: SonarQube Scan
          # - defectdojo_report_file: trivy-sca-report.json
          #   defectdojo_scan_type: Trivy Scan
          #   defectdojo_test_title: Trivy SCA Scan
          # - defectdojo_report_file: trivy-iac-report.json
          #   defectdojo_scan_type: Trivy Scan
          #   defectdojo_test_title: Trivy IaC Scan
          # - defectdojo_report_file: trivy-image-report.json
          #   defectdojo_scan_type: Trivy Scan
          #   defectdojo_test_title: Trivy Image Scan
          # - defectdojo_report_file: zap-baseline-report.xml
          #   defectdojo_scan_type: ZAP Scan
          #   defectdojo_test_title: ZAP Scan Baseline
          # - defectdojo_report_file: zap-api-report.xml
          #   defectdojo_scan_type: ZAP Scan
          #   defectdojo_test_title: ZAP Scan API
          # - defectdojo_report_file: zap-full-report.xml
          #   defectdojo_scan_type: ZAP Scan
          #   defectdojo_test_title: ZAP Scan Full
